# 行动条 (Action Gauge) 系统设计

为了实现“速度越快，行动次数越多”的核心体验，我们将战斗系统从**固定回合制 (Round-based)** 重构为 **CT/行动条制 (CT-based)**。

## 1. 核心公式

*   **MAX_AG (行动条上限)**: 10000
*   **SPD (速度)**: 单位的当前速度 (含 Buff)
*   **AV (Action Value, 行动值)**: 距离下次行动还需要的时间单位。
    *   `AV = (MAX_AG - currentAG) / SPD`

## 2. 战斗循环逻辑

不再使用固定的 `turnOrder` 数组，而是动态计算下一个行动者。

### 旧逻辑 (Round-based)
```javascript
function startRound() {
    units.sort((a, b) => b.spd - a.spd);
    units.forEach(unit => unit.act());
}
```

### 新逻辑 (CT-based)
```javascript
function nextTurn() {
    // 1. 寻找跑得最快的单位（AV 最小）
    let minAV = Infinity;
    let nextUnit = null;
    
    allUnits.forEach(unit => {
        const needed = 10000 - unit.actionGauge;
        const av = needed / getUnitSpd(unit);
        if (av < minAV) {
            minAV = av;
            nextUnit = unit;
        }
    });
    
    // 2. 时间流逝，全员跑条
    allUnits.forEach(unit => {
        unit.actionGauge += getUnitSpd(unit) * minAV;
    });
    
    // 3. 修正误差（确保 nextUnit 刚好满条或微溢出）
    // nextUnit.actionGauge 应该是 >= 10000 的
    
    // 4. 执行行动
    executeAction(nextUnit);
}

function onActionEnd(unit) {
    // 行动结束，扣除条
    unit.actionGauge -= 10000;
    
    // 触发下一回合
    nextTurn();
}
```

## 3. 速度突破收益演示

假设标准速度为 100。
*   **单位 A (SPD 100)**: 跑满需 100 时间单位。
*   **单位 B (SPD 140, 突破后)**: 跑满需 71.4 时间单位。

**时间轴演示**:
*   **T=0**: 比赛开始。
*   **T=71.4**: **B 行动 (1)**。B 重跑。
    *   A 进度: 71.4%
*   **T=100**: **A 行动 (1)**。A 重跑。
    *   B 进度: (100-71.4)*1.4 = 40%
*   **T=142.8**: **B 行动 (2)**。B 重跑。
    *   A 进度: 42.8%
*   **T=200**: **A 行动 (2)**。
    *   B 进度: 80%
*   **T=214.2**: **B 行动 (3)**。
    *   A 进度: 14.2%

**结论**: 在 A 行动 2 次的时间点 (T=200)，B 已经行动完 2 次且马上要行动第 3 次 (T=214)。
如果战斗时间拉长到 T=700：
*   A 行动 7 次。
*   B 行动 700/71.4 ≈ 9.8 次 (接近 10 次)。
*   **收益**: 行动频率提升 40%，符合预期。

## 4. 特殊情况处理

1.  **开局**: 所有单位初始 `actionGauge` 为 0？
    *   优化：为了避免开局大家一起跑，可以让初始 AG = `Random(0, 500)` 或者基于 SPD 预跑一段。
    *   更简单的方案：开局 AG = 0，直接跑第一轮。SPD 高的自然先满。
    
2.  **Buff 持续时间**:
    *   保持现状：Buff 在单位**自身回合结束**时 -1。
    *   这意味着高得干员，Buff 消耗得也快（这是合理的平衡）。

3.  **行动条溢出**:
    *   如果 A 和 B 同时满条（极小概率），或者因为技能导致 AG 增加。
    *   处理：优先处理 AG 溢出最多的单位。

4.  **拉条/推条技能 (未来扩展)**:
    *   `AG += 2000` (拉条 20%)
    *   `AG -= 2000` (推条 20%)
    *   本系统天然支持这种机制。

## 5. 修改计划

1.  **数据结构**: 给每个单位添加 `actionGauge` (初始 0)。
2.  **核心循环**: 替换 `js/battle.js` 中的 `calculateTurnOrder` 和 `nextTurn`。
3.  **UI**: 在日志中显示“[系统] 经过了 X 秒，轮到 xxx 行动”。